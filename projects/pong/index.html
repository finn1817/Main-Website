<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pong — Inline Edition</title>
  <style>
    :root { color-scheme: dark light; }
    html, body { margin: 0; height: 100%; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    body[data-theme="dark"] { background: #0b0b0b; color: #eaeaea; }
    body[data-theme="light"] { background: #f7f7f9; color: #111; }
    header {
      position: fixed; left: 0; right: 0; top: 0; height: 44px;
      display: flex; align-items: center; gap: 8px; padding: 0 10px;
      backdrop-filter: blur(6px);
      z-index: 3; border-bottom: 1px solid;
    }
    body[data-theme="dark"] header { background: #101010cc; border-color: #1f1f1f; }
    body[data-theme="light"] header { background: #ffffffcc; border-color: #ddd; }
    header .title { font-weight: 800; letter-spacing: 0.3px; font-size: 13px; opacity: 0.9; }
    header .spacer { flex: 1; }
    header button {
      height: 28px; padding: 0 10px; font: inherit; border-radius: 8px; cursor: pointer; border: 1px solid;
    }
    body[data-theme="dark"] header button { color: #eaeaea; background: #1a1a1a; border-color: #2a2a2a; }
    body[data-theme="dark"] header button:hover { background: #222; }
    body[data-theme="light"] header button { color: #111; background: #f0f0f3; border-color: #d5d5da; }
    body[data-theme="light"] header button:hover { background: #e7e7ed; }

    .wrap { position: fixed; inset: 44px 0 0 0; display: grid; place-items: center; }
    canvas { image-rendering: pixelated; image-rendering: crisp-edges; background: #000; box-shadow: 0 8px 32px rgba(0,0,0,0.4); border: 1px solid; touch-action: none; }
    body[data-theme="dark"] canvas { border-color: #222; }
    body[data-theme="light"] canvas { border-color: #ccc; background: #fff; }

    /* Settings panel */
    #settings {
      position: fixed; top: 54px; right: 10px; width: 280px; max-width: calc(100% - 20px);
      border: 1px solid; border-radius: 12px; padding: 12px; z-index: 4; display: none;
      box-shadow: 0 10px 40px rgba(0,0,0,0.25);
    }
    body[data-theme="dark"] #settings { background: #0e0e0e; border-color: #262626; color: #eaeaea; }
    body[data-theme="light"] #settings { background: #fff; border-color: #ddd; color: #111; }

    #settings.open { display: block; }
    #settings h3 { margin: 6px 0 10px; font-size: 14px; }
    .row { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 8px; margin: 8px 0; }
    .row > label { font-size: 12px; opacity: 0.9; }
    .row > input[type="range"], .row > select { width: 150px; }
    .hint { font-size: 11px; opacity: 0.7; margin-top: 6px; }
    .k { opacity: 0.7; }

    footer { position: fixed; left: 0; right: 0; bottom: 0; text-align: center; font-size: 12px; opacity: 0.8; padding: 6px 0; pointer-events: none; }
  </style>
</head>
<body data-theme="dark">
  <header>
    <div class="title">Pong</div>
    <div class="spacer"></div>
    <button id="btn-theme" title="Toggle Theme">Light/Dark</button>
    <button id="btn-settings" title="Settings (O)">⚙️</button>
    <button id="btn-fullscreen" title="Fullscreen (F)">⛶</button>
    <button id="btn-reset" title="Reset (R)">Reset</button>
  </header>

  <div id="settings" aria-label="Settings panel">
    <h3>Settings</h3>

    <div class="row">
      <label>Right Paddle: AI</label>
      <input id="s-ai" type="checkbox" />
    </div>

    <div class="row">
      <label>AI Difficulty</label>
      <div style="display:flex; gap:6px;">
        <button id="ai-easy">Easy</button>
        <button id="ai-medium">Medium</button>
        <button id="ai-hard">Hard</button>
      </div>
    </div>

    <div class="row">
      <label>Paddle Height</label>
      <input id="s-paddle" type="range" min="22" max="64" step="2" />
    </div>

    <div class="row">
      <label>Ball Speed x</label>
      <input id="s-speed" type="range" min="0.8" max="1.8" step="0.05" />
    </div>

    <div class="row">
      <label>Win Score</label>
      <select id="s-win">
        <option>5</option><option selected>11</option><option>15</option><option>21</option>
      </select>
    </div>

    <div class="row">
      <label>Spin</label>
      <input id="s-spin" type="checkbox" />
    </div>

    <div class="row">
      <label>Sound</label>
      <input id="s-sound" type="checkbox" />
    </div>

    <div class="row">
      <label>Theme</label>
      <select id="s-theme">
        <option value="classic" selected>Classic</option>
        <option value="neon">Neon</option>
        <option value="dmg">DMG</option>
      </select>
    </div>

    <div class="row">
      <label>Reset Stats</label>
      <button id="btn-clear-stats" style="justify-self:end;">Clear</button>
    </div>

    <div class="hint">
      Controls: W/S (P1), Up/Down (P2), Space serve, P pause, R reset, O settings, F fullscreen.
    </div>
  </div>

  <div class="wrap">
    <canvas id="game" width="320" height="180" aria-label="Pong game canvas"></canvas>
  </div>

  <footer>W/S = P1 • Up/Down = P2 • Space = Serve • P = Pause • R = Reset • O = Settings • F = Fullscreen</footer>

  <script>

    // if your reading this, good luck... bit of a mess but its working!

    // idea: remake pong with only simple base code from scratch


    
    // constants
    const GAME_W = 320, GAME_H = 180, TARGET_HZ = 60, FIXED_DT = 1 / TARGET_HZ;
    const STORE_SETTINGS = 'pong.inline.settings.v1';
    const STORE_STATS = 'pong.inline.stats.v1';

    // default settings
    const DEFAULTS = {
      aiEnabled: true,
      aiDifficulty: 'medium', // easy | medium | hard
      paddleH: 34,
      ballSpeedMul: 1.0,
      winningScore: 11,
      themeStyle: 'classic', // canvas theme
      uiTheme: 'dark',       // page theme light/dark
      sound: true,
      spin: true
    };

    // stats to persist
    const DEFAULT_STATS = {
      matchesPlayed: 0,
      p1Wins: 0,
      p2Wins: 0,
      bestWinMargin: 0
    };

    // load/save settings
    function loadJSON(key, fallback) {
      try {
        const raw = localStorage.getItem(key);
        if (!raw) return { ...fallback };
        const obj = JSON.parse(raw);
        return { ...fallback, ...obj };
      } catch {
        return { ...fallback };
      }
    }
    function saveJSON(key, obj) {
      try { localStorage.setItem(key, JSON.stringify(obj)); } catch {}
    }

    const cfg = loadJSON(STORE_SETTINGS, DEFAULTS);
    const stats = loadJSON(STORE_STATS, DEFAULT_STATS);

    // dom
    const body = document.body;
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: false });
    const $ = (id) => document.getElementById(id);

    // apply UI theme on load
    body.setAttribute('data-theme', cfg.uiTheme === 'light' ? 'light' : 'dark');

    // wire header buttons
    $('#btn-settings').addEventListener('click', toggleSettings);
    $('#btn-reset').addEventListener('click', () => reset(true));
    $('#btn-fullscreen').addEventListener('click', tryFullscreen);
    $('#btn-theme').addEventListener('click', () => {
      setCfg('uiTheme', (cfg.uiTheme === 'light') ? 'dark' : 'light');
      body.setAttribute('data-theme', cfg.uiTheme);
    });

    // keyboard global
    let paused = false, awaitingServe = true;
    window.addEventListener('keydown', (e) => {
      if (['ArrowUp','ArrowDown','w','s','W','S',' '].includes(e.key)) e.preventDefault();
      if (e.key === 'p' || e.key === 'P') paused = !paused;
      if (e.key === 'r' || e.key === 'R') reset(true);
      if (e.key === 'o' || e.key === 'O') toggleSettings();
      if (e.key === 'f' || e.key === 'F') tryFullscreen();
      if (e.key === ' ') tryServe();
    }, { passive: false });

    // settings panel init
    initSettingsPanel();

    // resize scaling (pixel-perfect integer scale)
    function resize() {
      const maxX = Math.floor((window.innerWidth) / GAME_W) || 1;
      const maxY = Math.floor((window.innerHeight - 44) / GAME_H) || 1;
      const scale = Math.max(1, Math.min(maxX, maxY));
      canvas.style.width = (GAME_W * scale) + 'px';
      canvas.style.height = (GAME_H * scale) + 'px';
      canvas.width = GAME_W; canvas.height = GAME_H;
      ctx.imageSmoothingEnabled = false;
    }
    window.addEventListener('resize', resize);
    resize();

    // input tracking
    const keys = new Set();
    window.addEventListener('keydown', (e) => keys.add(e.key));
    window.addEventListener('keyup', (e) => keys.delete(e.key));

    // touch: drag on canvas controls left paddle (works on mobile)
    let touching = false;
    canvas.addEventListener('pointerdown', (e) => { touching = true; updatePaddleFromPointer(e); });
    canvas.addEventListener('pointermove', (e) => { if (touching) updatePaddleFromPointer(e); });
    canvas.addEventListener('pointerup', () => touching = false);
    function updatePaddleFromPointer(e) {
      const rect = canvas.getBoundingClientRect();
      const y = ((e.clientY - rect.top) / rect.height) * GAME_H;
      p1.y = clamp(y - p1.h / 2, 2, GAME_H - p1.h - 2);
    }

    // game state
    const p1 = { x: 8, y: GAME_H/2 - cfg.paddleH/2, w: 4, h: cfg.paddleH };
    const p2 = { x: GAME_W - 12, y: GAME_H/2 - cfg.paddleH/2, w: 4, h: cfg.paddleH };
    const ball = { x: GAME_W/2, y: GAME_H/2, r: 2.5, vx: 0, vy: 0 };
    let p1Score = 0, p2Score = 0;

    // canvas color themes
    const THEMES = {
      classic: { bg:'#000', net:'#444', fg:'#fff', text:'#eaeaea', hud:'#9aa0a6' },
      neon:    { bg:'#05060a', net:'#182a35', fg:'#2ee6a6', text:'#b7fff1', hud:'#6ad6ff' },
      dmg:     { bg:'#0f380f', net:'#224422', fg:'#8bac0f', text:'#c4f000', hud:'#9bbc0f' }
    };

    // audio
    let actx = null;
    function ensureAudio() { if (!actx) { try { actx = new (window.AudioContext || window.webkitAudioContext)(); } catch {} } }
    function beep(freq=440, dur=0.06, type='square', vol=0.03) {
      if (!cfg.sound) return;
      ensureAudio(); if (!actx) return;
      const t0 = actx.currentTime;
      const o = actx.createOscillator(); const g = actx.createGain();
      o.type = type; o.frequency.value = freq; g.gain.value = vol;
      o.connect(g).connect(actx.destination);
      o.start(t0); o.stop(t0 + dur);
    }

    // helpers
    function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
    function rectCircleOverlap(rect, cx, cy, r) {
      const nx = clamp(cx, rect.x, rect.x+rect.w);
      const ny = clamp(cy, rect.y, rect.y+rect.h);
      const dx = cx - nx, dy = cy - ny;
      return dx*dx + dy*dy <= r*r;
    }

    // AI parameters — tuned so Easy is truly easy, Hard is strong but beatable
    function aiParams() {
      switch (cfg.aiDifficulty) {
        case 'easy':   return { speed: 105, jitter: 0.55, reaction: 0.10, missChance: 0.05 };
        case 'hard':   return { speed: 185, jitter: 0.06, reaction: 0.02, missChance: 0.0 };
        default:       return { speed: 145, jitter: 0.18, reaction: 0.06, missChance: 0.01 }; // medium
      }
    }

    // core ops
    function reset(full=false) {
      p1.h = p2.h = cfg.paddleH;
      p1.y = GAME_H/2 - p1.h/2; p2.y = GAME_H/2 - p2.h/2;
      ball.x = GAME_W/2; ball.y = GAME_H/2; ball.vx = 0; ball.vy = 0;
      awaitingServe = true;
      if (full) { p1Score = 0; p2Score = 0; paused = false; }
    }

    function tryServe() {
      if (!awaitingServe) return;
      awaitingServe = false; ensureAudio();
      const dir = Math.random()<0.5?-1:1;
      const base = 100 * cfg.ballSpeedMul;
      const angle = (Math.random()*0.5 - 0.25);
      ball.vx = dir * base * (1 + Math.abs(angle)*0.4);
      ball.vy = base * angle;
    }

    function finishMatch() {
      stats.matchesPlayed += 1;
      const margin = Math.abs(p1Score - p2Score);
      stats.bestWinMargin = Math.max(stats.bestWinMargin, margin);
      if (p1Score > p2Score) stats.p1Wins += 1; else stats.p2Wins += 1;
      saveJSON(STORE_STATS, stats);
    }

    function score(pointRight) {
      if (pointRight) p2Score++; else p1Score++;
      beep(220,0.09,'sawtooth',0.04);
      if (p1Score >= cfg.winningScore || p2Score >= cfg.winningScore) {
        paused = true;
        finishMatch();
      }
      reset(false);
    }

    // game update
    function update(dt) {
      // player 1 keyboard
      const P1S = 160;
      let dy1 = 0;
      if (keys.has('w') || keys.has('W')) dy1 -= 1;
      if (keys.has('s') || keys.has('S')) dy1 += 1;
      const p1PrevY = p1.y;
      p1.y += dy1 * P1S * dt;

      // player 2 (AI or player)
      const p2PrevY = p2.y;
      if (cfg.aiEnabled) {
        const { speed, jitter, reaction, missChance } = aiParams();
        // react only when ball is moving right and past mid a bit
        const tracking = (ball.vx > 0 && ball.x > GAME_W * (0.45 + reaction));
        let targetY = p2.y + p2.h/2;

        if (tracking) {
          // predict simple future position with slight lead
          const timeToReach = Math.max(0.01, (p2.x - ball.x) / Math.max(30, ball.vx));
          targetY = ball.y + ball.vy * timeToReach;
          // add jitter noise scaled by difficulty and a small bias to cause mistakes
          const noise = (Math.random() - 0.5) * p2.h * jitter;
          targetY += noise;
          // occasional intentional miss offset on easy/medium
          if (Math.random() < missChance) targetY += (Math.random() < 0.5 ? -1 : 1) * p2.h * (0.8 + Math.random()*0.6);
        } else {
          // drift back to center with slight noise
          targetY = GAME_H/2 + (Math.random()-0.5) * 6;
        }

        const center = p2.y + p2.h/2;
        const delta = targetY - center;
        const maxMove = speed * dt;
        p2.y += clamp(delta, -maxMove, maxMove);
      } else {
        const P2S = 160;
        let dy2 = 0;
        if (keys.has('ArrowUp')) dy2 -= 1;
        if (keys.has('ArrowDown')) dy2 += 1;
        p2.y += dy2 * P2S * dt;
      }

      // clamp paddles
      p1.y = clamp(p1.y, 2, GAME_H - p1.h - 2);
      p2.y = clamp(p2.y, 2, GAME_H - p2.h - 2);

      // ball physics
      if (!awaitingServe) {
        ball.x += ball.vx * dt; ball.y += ball.vy * dt;

        // walls
        if (ball.y - ball.r < 0) { ball.y = ball.r; ball.vy = Math.abs(ball.vy); beep(800,0.03); }
        if (ball.y + ball.r > GAME_H) { ball.y = GAME_H - ball.r; ball.vy = -Math.abs(ball.vy); beep(800,0.03); }

        // paddle collisions + spin
        const spinFactor = cfg.spin ? 45 : 0;
        if (rectCircleOverlap(p1, ball.x, ball.y, ball.r) && ball.vx < 0) {
          const hitPos = ((ball.y - (p1.y + p1.h/2)) / (p1.h/2)); // -1..1
          const speed = Math.hypot(ball.vx, ball.vy) * 1.05 + 5;
          const newAngle = hitPos * 0.6;
          ball.vx = Math.abs(Math.cos(newAngle) * speed);
          ball.vy = Math.sin(newAngle) * speed + (p1.y - p1PrevY) * spinFactor;
          ball.x = p1.x + p1.w + ball.r + 0.01;
          beep(600,0.025);
        } else if (rectCircleOverlap(p2, ball.x, ball.y, ball.r) && ball.vx > 0) {
          const hitPos = ((ball.y - (p2.y + p2.h/2)) / (p2.h/2));
          const speed = Math.hypot(ball.vx, ball.vy) * 1.05 + 5;
          const newAngle = hitPos * 0.6;
          ball.vx = -Math.abs(Math.cos(newAngle) * speed);
          ball.vy = Math.sin(newAngle) * speed + (p2.y - p2PrevY) * spinFactor;
          ball.x = p2.x - ball.r - 0.01;
          beep(600,0.025);
        }

        // scoring
        if (ball.x < -10) score(true);
        else if (ball.x > GAME_W + 10) score(false);
      }

      // gamepad: first pad controls P1
      const pads = navigator.getGamepads ? navigator.getGamepads() : [];
      const gp = pads && pads[0];
      if (gp && gp.connected) {
        const y = Math.abs(gp.axes[1]) > 0.12 ? gp.axes[1] : (gp.buttons[12]?.pressed ? -1 : gp.buttons[13]?.pressed ? 1 : 0);
        p1.y = clamp(p1.y + y * 160 * dt, 2, GAME_H - p1.h - 2);
        if (gp.buttons[0]?.pressed) tryServe(); // A / Cross
      }
    }

    // drawing
    let fps=60, fpsAcc=0, fpsFrames=0, lastTime = performance.now(), acc = 0;
    function drawNet(theme) {
      ctx.fillStyle = theme.net;
      const dashH = 6, gap = 5, w = 2;
      for (let y = 0; y < GAME_H; y += dashH + gap) ctx.fillRect(GAME_W/2 - w/2, y, w, dashH);
    }

    function overlay(text) {
      ctx.fillStyle = 'rgba(0,0,0,0.55)'; ctx.fillRect(0,0,GAME_W,GAME_H);
      const theme = THEMES[cfg.themeStyle] || THEMES.classic;
      ctx.fillStyle = theme.fg; ctx.font = '12px monospace'; ctx.textAlign = 'center';
      ctx.fillText(text, GAME_W/2, GAME_H/2);
    }

    function draw() {
      const theme = THEMES[cfg.themeStyle] || THEMES.classic;
      ctx.fillStyle = theme.bg; ctx.fillRect(0,0,GAME_W,GAME_H);
      drawNet(theme);

      // paddles + ball
      ctx.fillStyle = theme.fg;
      ctx.fillRect(p1.x, Math.round(p1.y), p1.w, p1.h);
      ctx.fillRect(p2.x, Math.round(p2.y), p2.w, p2.h);
      ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2); ctx.fill();

      // scores
      ctx.fillStyle = theme.text; ctx.font = '10px monospace'; ctx.textAlign = 'center';
      ctx.fillText(String(p1Score).padStart(2,'0'), GAME_W/2 - 24, 16);
      ctx.fillText(String(p2Score).padStart(2,'0'), GAME_W/2 + 24, 16);

      // HUD left: AI + difficulty; right: FPS; bottom center: stats summary
      ctx.textAlign = 'left'; ctx.fillStyle = theme.hud; ctx.fillText(`AI:${cfg.aiEnabled ? cfg.aiDifficulty.toUpperCase() : 'OFF'}`, 6, GAME_H - 6);
      ctx.textAlign = 'right'; ctx.fillText(`${Math.round(fps)} FPS`, GAME_W - 6, GAME_H - 6);

      // overlay messages
      if (paused) overlay('Paused — P to resume');
      else if (awaitingServe) overlay('Press Space (or A) to serve');
    }

    function frame(now) {
      const dt = Math.min(0.25, (now - lastTime) / 1000); lastTime = now;
      if (!paused) {
        acc += dt; let steps=0;
        while (acc >= FIXED_DT && steps < 5) { update(FIXED_DT); acc -= FIXED_DT; steps++; }
      }
      fpsAcc += dt; fpsFrames++; if (fpsAcc >= 0.5) { fps = fpsFrames / fpsAcc; fpsAcc = 0; fpsFrames = 0; }
      draw();
      requestAnimationFrame(frame);
    }

    // settings and UI helpers
    function initSettingsPanel() {
      // initialize values
      $('#s-ai').checked = cfg.aiEnabled;
      $('#s-paddle').value = cfg.paddleH;
      $('#s-speed').value = cfg.ballSpeedMul;
      $('#s-win').value = String(cfg.winningScore);
      $('#s-theme').value = cfg.themeStyle;
      $('#s-sound').checked = cfg.sound;
      $('#s-spin').checked = cfg.spin;

      // difficulty buttons state
      function setDiffButtons() {
        for (const id of ['ai-easy','ai-medium','ai-hard']) $(id).style.opacity = '0.6';
        if (cfg.aiDifficulty === 'easy') $('#ai-easy').style.opacity = '1';
        else if (cfg.aiDifficulty === 'hard') $('#ai-hard').style.opacity = '1';
        else $('#ai-medium').style.opacity = '1';
      }
      setDiffButtons();

      // all the listeners
      $('#s-ai').addEventListener('change', (e)=> setCfg('aiEnabled', e.target.checked));
      $('#s-paddle').addEventListener('input', (e)=> setCfg('paddleH', parseInt(e.target.value,10), true));
      $('#s-speed').addEventListener('input', (e)=> setCfg('ballSpeedMul', parseFloat(e.target.value)));
      $('#s-win').addEventListener('change', (e)=> setCfg('winningScore', parseInt(e.target.value,10), true));
      $('#s-theme').addEventListener('change', (e)=> setCfg('themeStyle', e.target.value));
      $('#s-sound').addEventListener('change', (e)=> setCfg('sound', e.target.checked));
      $('#s-spin').addEventListener('change', (e)=> setCfg('spin', e.target.checked));

      $('#ai-easy').addEventListener('click', ()=> { setCfg('aiDifficulty','easy'); setDiffButtons(); });
      $('#ai-medium').addEventListener('click', ()=> { setCfg('aiDifficulty','medium'); setDiffButtons(); });
      $('#ai-hard').addEventListener('click', ()=> { setCfg('aiDifficulty','hard'); setDiffButtons(); });

      $('#btn-clear-stats').addEventListener('click', () => {
        Object.assign(stats, { ...DEFAULT_STATS });
        saveJSON(STORE_STATS, stats);
        beep(300,0.07,'triangle',0.05);
      });
    }

    function toggleSettings() {
      const panel = $('#settings');
      panel.classList.toggle('open');
    }

    function setCfg(key, value, resetPositions=false) {
      cfg[key] = value; saveJSON(STORE_SETTINGS, cfg);
      if (key === 'uiTheme') {
        body.setAttribute('data-theme', cfg.uiTheme);
      }
      if (key === 'paddleH' || key === 'winningScore') reset(resetPositions);
    }

    function tryFullscreen() {
      const root = document.documentElement;
      if (!document.fullscreenElement) root.requestFullscreen?.();
      else document.exitFullscreen?.();
    }

    // start
    reset(true);
    requestAnimationFrame((t)=>{ lastTime = t; requestAnimationFrame(frame); });
  </script>
</body>
</html>