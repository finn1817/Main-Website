<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Dan's Pong</title>
  <style>
    :root { color-scheme: dark light; }
    html, body { margin: 0; height: 100%; overflow: hidden; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    
    /* Themes */
    body[data-theme="dark"] { background: #0b0b0b; color: #eaeaea; --bg-panel: #0e0e0e; --border: #262626; --btn-bg: #1a1a1a; --btn-hover: #222; }
    body[data-theme="light"] { background: #f7f7f9; color: #111; --bg-panel: #fff; --border: #ddd; --btn-bg: #f0f0f3; --btn-hover: #e7e7ed; }

    /* Header */
    header {
      position: fixed; left: 0; right: 0; top: 0; height: 44px;
      display: flex; align-items: center; gap: 8px; padding: 0 10px;
      backdrop-filter: blur(10px); z-index: 10; border-bottom: 1px solid var(--border);
      background: rgba(0,0,0,0.2); /* Fallback */
    }
    body[data-theme="light"] header { background: rgba(255,255,255,0.8); }
    body[data-theme="dark"] header { background: rgba(16,16,16,0.8); }

    header .title { font-weight: 800; letter-spacing: 0.5px; font-size: 14px; opacity: 0.9; }
    header .spacer { flex: 1; }
    header button {
      height: 28px; padding: 0 12px; font: inherit; font-size: 12px; border-radius: 6px; 
      cursor: pointer; border: 1px solid var(--border); 
      background: var(--btn-bg); color: inherit; transition: 0.1s;
    }
    header button:hover { background: var(--btn-hover); }

    /* Game Container */
    .wrap { position: fixed; inset: 44px 0 0 0; display: grid; place-items: center; z-index: 1; }
    canvas { 
      image-rendering: pixelated; background: #000; 
      box-shadow: 0 20px 50px rgba(0,0,0,0.5); 
      border: 1px solid var(--border); touch-action: none; 
    }
    body[data-theme="light"] canvas { border-color: #ccc; background: #fff; }

    /* Start Menu Overlay */
    #start-menu {
      position: fixed; inset: 0; z-index: 20;
      background: rgba(0,0,0,0.85); backdrop-filter: blur(4px);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
    }
    #start-menu h1 { font-size: 60px; margin: 0 0 20px 0; letter-spacing: 4px; text-transform: uppercase; color: #fff; }
    #start-menu button {
      padding: 12px 32px; font-size: 18px; font-weight: bold; cursor: pointer;
      background: #eaeaea; border: none; border-radius: 4px; color: #000;
      transition: transform 0.1s;
    }
    #start-menu button:hover { transform: scale(1.05); background: #fff; }
    #start-menu.hidden { display: none; }

    /* Settings Panel */
    #settings {
      position: fixed; top: 54px; right: 10px; width: 280px; max-width: calc(100% - 20px);
      background: var(--bg-panel); border: 1px solid var(--border);
      border-radius: 12px; padding: 16px; z-index: 30; 
      box-shadow: 0 10px 40px rgba(0,0,0,0.4);
      display: none; /* Hidden by default */
    }
    #settings.open { display: block; animation: popIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
    @keyframes popIn { from { opacity: 0; transform: scale(0.95) translateY(-10px); } to { opacity: 1; transform: scale(1) translateY(0); } }

    #settings h3 { margin: 0 0 12px; font-size: 14px; border-bottom: 1px solid var(--border); padding-bottom: 8px; }
    .row { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 8px; margin: 10px 0; }
    .row label { font-size: 12px; opacity: 0.9; }
    .row input[type="range"], .row select { width: 140px; }
    .diff-group { display: flex; gap: 4px; }
    .diff-group button { 
      flex: 1; padding: 4px; font-size: 10px; cursor: pointer; 
      background: var(--btn-bg); border: 1px solid var(--border); color: inherit;
    }
    .diff-group button.active { background: #444; color: #fff; border-color: #666; }
    body[data-theme="light"] .diff-group button.active { background: #333; }

    .hint { font-size: 11px; opacity: 0.6; margin-top: 12px; line-height: 1.4; border-top: 1px solid var(--border); padding-top: 8px; }
    footer { position: fixed; left: 0; right: 0; bottom: 0; text-align: center; font-size: 11px; opacity: 0.5; padding: 8px; pointer-events: none; z-index: 2; }
  </style>
</head>
<body data-theme="dark">

  <!-- Start Menu -->
  <div id="start-menu">
    <h1>PONG</h1>
    <button id="btn-start-game">START GAME</button>
  </div>

  <header>
    <div class="title">Pong</div>
    <div class="spacer"></div>
    <button id="btn-theme">Light/Dark</button>
    <button id="btn-settings" title="Settings (O)">⚙️</button>
    <button id="btn-fullscreen" title="Fullscreen (F)">⛶</button>
    <button id="btn-reset" title="Reset (R)">Reset</button>
  </header>

  <div id="settings" aria-label="Settings panel">
    <h3>Settings</h3>
    <div class="row">
      <label>Right Paddle: AI</label>
      <input id="s-ai" type="checkbox" />
    </div>
    <div class="row">
      <label>AI Difficulty</label>
      <div class="diff-group">
        <button id="ai-easy">Easy</button>
        <button id="ai-medium">Med</button>
        <button id="ai-hard">Hard</button>
      </div>
    </div>
    <div class="row">
      <label>Paddle Height</label>
      <input id="s-paddle" type="range" min="22" max="64" step="2" />
    </div>
    <div class="row">
      <label>Ball Speed</label>
      <input id="s-speed" type="range" min="0.8" max="1.8" step="0.05" />
    </div>
    <div class="row">
      <label>Win Score</label>
      <select id="s-win">
        <option>5</option><option selected>11</option><option>15</option><option>21</option>
      </select>
    </div>
    <div class="row">
      <label>Spin Effects</label>
      <input id="s-spin" type="checkbox" />
    </div>
    <div class="row">
      <label>Sound</label>
      <input id="s-sound" type="checkbox" />
    </div>
    <div class="row">
      <label>Visual Theme</label>
      <select id="s-theme">
        <option value="classic">Classic</option>
        <option value="neon">Neon</option>
        <option value="dmg">Gameboy</option>
      </select>
    </div>
    <div class="row">
      <label>Stats</label>
      <button id="btn-clear-stats" style="font-size:10px; padding:2px 8px;">Clear Data</button>
    </div>
    <div class="hint">
      <strong>Controls:</strong> W/S or Arrows (Move)<br>Space (Serve) • P (Pause) • O (Settings)
    </div>
  </div>

  <div class="wrap">
    <canvas id="game" width="320" height="180"></canvas>
  </div>

  <footer>W/S or Up/Down = P1 • Space = Serve • P = Pause • R = Reset • O = Settings • F = Fullscreen</footer>

  <script>
    // --- 1. Constants & Global State (Defined FIRST to prevent crashes) ---
    const GAME_W = 320, GAME_H = 180;
    const STORE_KEY = 'pong_settings_v2';
    const STATS_KEY = 'pong_stats_v2';

    // Default Configuration
    const defaults = {
      aiEnabled: true,
      aiDifficulty: 'medium',
      paddleH: 34,
      ballSpeedMul: 1.0,
      winningScore: 11,
      themeStyle: 'classic',
      uiTheme: 'dark',
      sound: true,
      spin: true
    };

    // Load saved data
    let cfg = { ...defaults };
    try { Object.assign(cfg, JSON.parse(localStorage.getItem(STORE_KEY) || '{}')); } catch {}

    let stats = { matches: 0, p1Wins: 0, p2Wins: 0 };
    try { Object.assign(stats, JSON.parse(localStorage.getItem(STATS_KEY) || '{}')); } catch {}

    // Game Objects
    const p1 = { x: 8, y: 0, w: 4, h: cfg.paddleH };
    const p2 = { x: GAME_W - 12, y: 0, w: 4, h: cfg.paddleH };
    const ball = { x: 0, y: 0, r: 2.5, vx: 0, vy: 0 };
    
    // State Flags
    let gameActive = false; // False = Menu, True = Playing
    let paused = false;
    let awaitingServe = true;
    let p1Score = 0, p2Score = 0;
    let lastTime = 0;
    let actx = null; // Audio Context

    // DOM Elements (Populated in init)
    let canvas, ctx, body;

    // --- 2. Core Logic ---

    function init() {
      body = document.body;
      canvas = document.getElementById('game');
      ctx = canvas.getContext('2d', { alpha: false });

      // Apply initial UI theme
      body.setAttribute('data-theme', cfg.uiTheme);

      // Event Listeners
      document.getElementById('btn-start-game').addEventListener('click', startGame);
      document.getElementById('btn-theme').addEventListener('click', toggleTheme);
      document.getElementById('btn-settings').addEventListener('click', toggleSettings);
      document.getElementById('btn-reset').addEventListener('click', () => resetMatch(true));
      document.getElementById('btn-fullscreen').addEventListener('click', toggleFullscreen);

      // Keyboard
      window.addEventListener('keydown', handleInput);
      
      // Touch / Mouse Paddle Control
      let touching = false;
      const movePaddle = (e) => {
        if (!gameActive || paused) return;
        const rect = canvas.getBoundingClientRect();
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const y = ((clientY - rect.top) / rect.height) * GAME_H;
        p1.y = clamp(y - p1.h / 2, 2, GAME_H - p1.h - 2);
      };
      canvas.addEventListener('mousedown', (e) => { touching = true; movePaddle(e); });
      window.addEventListener('mousemove', (e) => { if (touching) movePaddle(e); });
      window.addEventListener('mouseup', () => touching = false);
      canvas.addEventListener('touchstart', (e) => { touching = true; movePaddle(e); }, {passive:true});
      canvas.addEventListener('touchmove', (e) => { if (touching) movePaddle(e); }, {passive:true});

      // Initialize Settings UI
      initSettingsUI();

      // Start Loop
      resetMatch(true);
      resize();
      window.addEventListener('resize', resize);
      requestAnimationFrame(loop);
    }

    function startGame() {
      // Audio context requires user gesture
      if (!actx) { try { actx = new (window.AudioContext || window.webkitAudioContext)(); } catch {} }
      
      document.getElementById('start-menu').classList.add('hidden');
      gameActive = true;
      resetMatch(true);
    }

    function resetMatch(full = false) {
      p1.h = p2.h = cfg.paddleH;
      p1.y = GAME_H/2 - p1.h/2;
      p2.y = GAME_H/2 - p2.h/2;
      ball.x = GAME_W/2; ball.y = GAME_H/2; ball.vx = 0; ball.vy = 0;
      awaitingServe = true;
      if (full) {
        p1Score = 0; p2Score = 0; paused = false;
      }
    }

    function serve() {
      if (!awaitingServe) return;
      awaitingServe = false;
      playTone(400, 0.1, 'triangle');
      const dir = Math.random() < 0.5 ? -1 : 1;
      const speed = 110 * cfg.ballSpeedMul;
      const angle = (Math.random() * 0.6 - 0.3); // -0.3 to 0.3 radians
      ball.vx = dir * speed;
      ball.vy = speed * angle;
    }

    function update(dt) {
      if (!gameActive || paused) return;

      // P1 Keyboard Movement
      const speed = 180;
      if (keys.has('w') || keys.has('W') || keys.has('ArrowUp')) p1.y -= speed * dt;
      if (keys.has('s') || keys.has('S') || keys.has('ArrowDown')) p1.y += speed * dt;
      p1.y = clamp(p1.y, 2, GAME_H - p1.h - 2);

      // P2 AI
      if (cfg.aiEnabled) {
        const params = {
          easy: { speed: 90, reaction: 0.15, error: 0.4 },
          medium: { speed: 140, reaction: 0.08, error: 0.15 },
          hard: { speed: 195, reaction: 0.02, error: 0.02 }
        }[cfg.aiDifficulty];

        // Only track if ball is coming towards AI
        let targetY = p2.y + p2.h/2;
        if (ball.vx > 0 && ball.x > GAME_W * params.reaction) {
          targetY = ball.y + (Math.random() - 0.5) * (p2.h * params.error);
        } else if (ball.vx <= 0) {
          targetY = GAME_H / 2; // Return to center
        }
        
        const diff = targetY - (p2.y + p2.h/2);
        p2.y += clamp(diff, -params.speed * dt, params.speed * dt);
      } else {
        // P2 Local Multiplayer
        if (keys.has('ArrowUp')) p2.y -= speed * dt;
        if (keys.has('ArrowDown')) p2.y += speed * dt;
      }
      p2.y = clamp(p2.y, 2, GAME_H - p2.h - 2);

      if (awaitingServe) return;

      // Ball Physics
      ball.x += ball.vx * dt;
      ball.y += ball.vy * dt;

      // Wall Bounce
      if (ball.y < ball.r) { ball.y = ball.r; ball.vy *= -1; playTone(800, 0.05); }
      if (ball.y > GAME_H - ball.r) { ball.y = GAME_H - ball.r; ball.vy *= -1; playTone(800, 0.05); }

      // Paddle Collision
      const checkPaddle = (p, isLeft) => {
        if (ball.y >= p.y && ball.y <= p.y + p.h) {
          // Horizontal overlap check
          const hit = isLeft ? (ball.x - ball.r <= p.x + p.w && ball.x > p.x) 
                             : (ball.x + ball.r >= p.x && ball.x < p.x + p.w);
          if (hit) {
            // Calculate hit position (-1 to 1)
            const hitPos = (ball.y - (p.y + p.h/2)) / (p.h/2);
            
            // Reflect
            ball.vx *= -1.05; // Speed up slightly
            ball.x = isLeft ? p.x + p.w + ball.r + 1 : p.x - ball.r - 1;
            
            // Add spin/angle
            ball.vy += hitPos * 50; 
            if (cfg.spin) ball.vy += (p.y - (p.y - (keys.has('w')?-1:keys.has('s')?1:0))) * 20;

            // Cap speed
            const maxS = 350;
            ball.vx = clamp(ball.vx, -maxS, maxS);
            ball.vy = clamp(ball.vy, -maxS, maxS);
            
            playTone(600, 0.05);
          }
        }
      };

      if (ball.vx < 0) checkPaddle(p1, true);
      else checkPaddle(p2, false);

      // Scoring
      if (ball.x < -10) scorePoint(2);
      if (ball.x > GAME_W + 10) scorePoint(1);
    }

    function scorePoint(player) {
      if (player === 1) p1Score++; else p2Score++;
      playTone(200, 0.2, 'sawtooth');
      
      if (p1Score >= cfg.winningScore || p2Score >= cfg.winningScore) {
        stats.matches++;
        if (p1Score > p2Score) stats.p1Wins++; else stats.p2Wins++;
        localStorage.setItem(STATS_KEY, JSON.stringify(stats));
        paused = true;
        setTimeout(() => resetMatch(true), 2000);
      } else {
        resetMatch(false);
      }
    }

    // --- 3. Rendering ---

    const themes = {
      classic: { bg:'#000', net:'#333', fg:'#fff' },
      neon:    { bg:'#05060a', net:'#182a35', fg:'#2ee6a6' },
      dmg:     { bg:'#0f380f', net:'#224422', fg:'#8bac0f' }
    };

    function draw() {
      const t = themes[cfg.themeStyle] || themes.classic;
      
      // Clear
      ctx.fillStyle = t.bg;
      ctx.fillRect(0, 0, GAME_W, GAME_H);

      // Net
      ctx.fillStyle = t.net;
      for(let y=4; y<GAME_H; y+=12) ctx.fillRect(GAME_W/2 - 1, y, 2, 6);

      // Objects
      ctx.fillStyle = t.fg;
      ctx.fillRect(p1.x, p1.y, p1.w, p1.h);
      ctx.fillRect(p2.x, p2.y, p2.w, p2.h);
      
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
      ctx.fill();

      // UI
      ctx.font = '10px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(p1Score, GAME_W/2 - 30, 20);
      ctx.fillText(p2Score, GAME_W/2 + 30, 20);

      // Overlay Text
      if (!gameActive) {
        // Menu is covering, draw nothing extra
      } else if (paused) {
        ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0,0,GAME_W,GAME_H);
        ctx.fillStyle = '#fff'; ctx.fillText("PAUSED", GAME_W/2, GAME_H/2);
      } else if (awaitingServe) {
        ctx.fillStyle = 'rgba(0,0,0,0.3)'; 
        if (Math.floor(Date.now()/500)%2===0) ctx.fillText("PRESS SPACE", GAME_W/2, GAME_H/2 + 20);
      }
    }

    function loop(now) {
      const dt = Math.min(0.1, (now - lastTime) / 1000);
      lastTime = now;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    // --- 4. Helpers & Settings ---

    const keys = new Set();
    function handleInput(e) {
      if (['ArrowUp','ArrowDown',' '].includes(e.key)) e.preventDefault();
      keys.add(e.key);
      window.addEventListener('keyup', (ev) => keys.delete(ev.key), {once:true});
      
      if (e.key === ' ' && gameActive) serve();
      if (e.key.toLowerCase() === 'p' && gameActive) paused = !paused;
      if (e.key.toLowerCase() === 'r' && gameActive) resetMatch(true);
      if (e.key.toLowerCase() === 'o') toggleSettings();
      if (e.key.toLowerCase() === 'f') toggleFullscreen();
    }

    function toggleSettings() {
      const el = document.getElementById('settings');
      el.classList.toggle('open');
      // Force pause when settings open
      if (el.classList.contains('open') && gameActive) paused = true;
    }

    function toggleTheme() {
      cfg.uiTheme = cfg.uiTheme === 'dark' ? 'light' : 'dark';
      body.setAttribute('data-theme', cfg.uiTheme);
      saveCfg();
    }

    function toggleFullscreen() {
      if (!document.fullscreenElement) document.documentElement.requestFullscreen();
      else document.exitFullscreen();
    }

    function resize() {
      // Integer scaling
      const scale = Math.max(1, Math.floor(Math.min(window.innerWidth/GAME_W, (window.innerHeight-44)/GAME_H)));
      canvas.style.width = (GAME_W * scale) + 'px';
      canvas.style.height = (GAME_H * scale) + 'px';
    }

    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

    function playTone(freq, dur, type='square') {
      if (!cfg.sound || !actx) return;
      const osc = actx.createOscillator();
      const gain = actx.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, actx.currentTime);
      gain.gain.setValueAtTime(0.05, actx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, actx.currentTime + dur);
      osc.connect(gain);
      gain.connect(actx.destination);
      osc.start();
      osc.stop(actx.currentTime + dur);
    }

    // Settings UI Wiring
    function initSettingsUI() {
      const bind = (id, key, type='val') => {
        const el = document.getElementById(id);
        if (!el) return;
        if (type === 'check') { el.checked = cfg[key]; el.onchange = () => { cfg[key] = el.checked; saveCfg(); }; }
        else { el.value = cfg[key]; el.oninput = () => { cfg[key] = (type==='num'?+el.value:el.value); saveCfg(); }; }
      };

      bind('s-ai', 'aiEnabled', 'check');
      bind('s-paddle', 'paddleH', 'num');
      bind('s-speed', 'ballSpeedMul', 'num');
      bind('s-win', 'winningScore', 'num');
      bind('s-spin', 'spin', 'check');
      bind('s-sound', 'sound', 'check');
      bind('s-theme', 'themeStyle');

      // Difficulty Buttons
      const diffs = ['easy','medium','hard'];
      const updateDiffUI = () => {
        diffs.forEach(d => document.getElementById('ai-'+d).classList.toggle('active', cfg.aiDifficulty === d));
      };
      diffs.forEach(d => {
        document.getElementById('ai-'+d).onclick = () => { cfg.aiDifficulty = d; updateDiffUI(); saveCfg(); };
      });
      updateDiffUI();

      document.getElementById('btn-clear-stats').onclick = () => {
        localStorage.removeItem(STATS_KEY);
        alert('Stats cleared');
      };
    }

    function saveCfg() {
      localStorage.setItem(STORE_KEY, JSON.stringify(cfg));
      // Immediate updates
      p1.h = p2.h = cfg.paddleH;
    }

    // Boot
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
    else init();

  </script>
</body>
</html>