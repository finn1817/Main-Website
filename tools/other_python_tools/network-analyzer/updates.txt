// The Strategy:
// - centralize data storage: I need a place to store all this new data (protocol counts, security alerts, unique DNS queries) so the UI can read it without race conditions.

// supercharge the Sniffer: My _packet_callback is about to get heavy. We need to optimize it so it doesn't lag out a computer.

// UI Integration: I already have the tabs setup; I just need to start feeding them the real data.

// here is my implementation plan broken down by my professor's 'requirements'.

1) update __init__ with new data structures
- Add these to __init__ method. This creates the "buckets" where the sniffer will dump data.

```

# add these to existing __init__ method
self.protocol_stats = defaultdict(int)
self.dns_queries = Counter()
self.detected_devices = []
self.security_alerts = deque(maxlen=50) # Store last 50 alerts
self.syn_tracker = defaultdict(set) # For Port Scan detection {IP: {ports}}
self.packet_times = deque(maxlen=1000) # For Jitter calc
self.network_profiles = {} # For Point 10

```

2) The "Supercharged" Sniffer (Points 1, 3, 4, 5, 7)
- replace existing _packet_callback with this better version. This single function handles half the requirements...

```

def _packet_callback(self, pkt):
    """
    The Master Analyzer: Handles DPI, IDS, and QoS in real-time.
    """
    # timestamp for QoS
    current_time = time.time()

    # --- 1. Protocol Distribution (Point 1) ---
    if IP in pkt:
        # Simple protocol counting
        if pkt.haslayer(TCP): self.protocol_stats['TCP'] += 1
        elif pkt.haslayer(UDP): self.protocol_stats['UDP'] += 1
        elif pkt.haslayer(ICMP): self.protocol_stats['ICMP'] += 1
        
        # Application Layer Guesses
        if pkt.haslayer(DNS): self.protocol_stats['DNS'] += 1
        if pkt.haslayer(TLS) or pkt.dport == 443: self.protocol_stats['HTTPS'] += 1
        if pkt.dport == 80: self.protocol_stats['HTTP'] += 1

    # --- 3. Intrusion Detection System (IDS) (Point 3) ---
    if TCP in pkt and pkt[IP].src != self.current_network.get('ip_address'):
        # Detect SYN Scan: External IP sending SYN to many ports
        if pkt[TCP].flags == 'S': 
            src_ip = pkt[IP].src
            self.syn_tracker[src_ip].add(pkt[TCP].dport)
            
            if len(self.syn_tracker[src_ip]) > 10:
                alert_msg = f"PORT SCAN DETECTED: {src_ip} hit {len(self.syn_tracker[src_ip])} ports"
                if alert_msg not in self.security_alerts:
                    self.security_alerts.append(alert_msg)
                    # Optional: Flash UI red or play sound

    # --- 4. Application Layer Analysis (DNS) (Point 4) ---
    if pkt.haslayer(DNS) and pkt[DNS].qr == 0: # It's a query
        try:
            query_name = pkt[DNS].qd.qname.decode('utf-8')
            if query_name:
                self.dns_queries[query_name] += 1
        except:
            pass

    # --- 5. QoS Analysis (Jitter/Latency) (Point 5) ---
    # We calculate Jitter based on inter-arrival time of packets
    if hasattr(self, 'last_packet_time'):
        inter_arrival = current_time - self.last_packet_time
        self.packet_times.append(inter_arrival)
    self.last_packet_time = current_time

    # --- 7. WiFi Deauth Detection (Point 7) ---
    # NOTE: This usually requires Monitor Mode (rare on standard Windows drivers)
    # But this is the code the professor wants to see.
    if pkt.haslayer(Dot11Deauth):
        alert_msg = f"WiFi DEAUTH ATTACK detected against {pkt.addr1}"
        self.security_alerts.append(alert_msg)

    # --- Keep your existing Bandwidth Logic below ---
    # (Your existing PID mapping code goes here...)

```

3) Network Topology Mapper (Point 2)
- create a new function run_topology_scan. Trigger this through a button in the UI. (Warning if anyone ever uses and reads this: This is aggressive.)

```

def run_topology_scan(self):
    """
    Uses Scapy ARP requests to map the LAN.
    (Point 2)
    """
    def _scan():
        # Get local subnet (assuming /24 for simplicity, or parse from self.current_network)
        my_ip = self.current_network.get('ip_address', '192.168.1.1')
        base_ip = ".".join(my_ip.split('.')[:3]) + ".0/24"
        
        # Scapy magic: Send ARP who-has to the whole subnet
        self.scan_status.configure(text="Mapping network topology...")
        ans, unans = arping(base_ip, timeout=2, verbose=0)
        
        self.detected_devices = []
        for sent, received in ans:
            device = {
                'ip': received.psrc,
                'mac': received.hwsrc,
                'vendor': self.get_vendor_from_mac(received.hwsrc)
            }
            self.detected_devices.append(device)
        
        # Update UI (You'll need to create a Treeview for this in a new tab)
        self.root.after(0, lambda: messagebox.showinfo("Scan Complete", f"Found {len(self.detected_devices)} devices on LAN."))
        
    threading.Thread(target=_scan, daemon=True).start()

```

4) NetFlow Export & ML Trends (Points 6 & 9)
- add these helper functions. The ML part uses numpy since sklearn might be bloat, but numpy.polyfit is mathematically standard for trend lines in engineering. - thanks

```

# --- Point 6: NetFlow/JSON Export ---
def export_netflow_data(self):
    """Exports captured stats to JSON for ELK stack or analysis."""
    data = {
        'timestamp': datetime.now().isoformat(),
        'protocol_distribution': self.protocol_stats,
        'top_dns_queries': self.dns_queries.most_common(10),
        'security_alerts': list(self.security_alerts),
        'devices': self.detected_devices
    }
    
    filename = f"netflow_dump_{int(time.time())}.json"
    with open(filename, 'w') as f:
        json.dump(data, f, indent=4)
    messagebox.showinfo("Export", f"NetFlow data exported to {filename}")

# --- Point 9: Historical Trend Analysis (ML) ---
def predict_network_congestion(self):
    """
    Uses Linear Regression (Least Squares) to predict when bandwidth will cap out.
    """
    if len(self.bandwidth_data['download']) < 10:
        return "Not enough data"

    # Get recent download speeds
    data = list(self.bandwidth_data['download'])[-50:] # Last 50 points
    y = np.array([d[1] for d in data]) # Speeds
    x = np.arange(len(y)) # Time steps
    
    # Calculate Trend Line (slope and intercept)
    slope, intercept = np.polyfit(x, y, 1)
    
    # Simple prediction logic
    trend = "Stable"
    if slope > 0.5: trend = "Rapidly Increasing (Risk of Congestion)"
    elif slope < -0.5: trend = "Decreasing"
    
    return f"Trend: {trend} (Slope: {slope:.2f})"

    ```
    
5) Multi-Network Comparison (Point 10)
- modify your logic where you detect the network. When you connect to a network, save the "profile".

```

def save_network_profile(self):
    """
    Saves current network stats for comparison.
    (Point 10)
    """
    ssid = self.current_network.get('ssid', 'Unknown')
    
    # Calculate averages from history
    avg_down = 0
    if self.speed_history:
        avg_down = sum(r['download'] for r in self.speed_history) / len(self.speed_history)

    profile = {
        'ssid': ssid,
        'avg_speed': avg_down,
        'gateway': self.router_info.get('ip'),
        'device_count': len(self.detected_devices)
    }
    
    self.network_profiles[ssid] = profile
    # You can now render a bar chart comparing self.network_profiles.values()

    ```


// tech notes for professor

// WiFi Deauth (The "Monitor Mode" Issue):
// - Real Talk: Point 7 (WiFi Deauth) often requires the WiFi adapter to be in "Monitor Mode." On standard Windows drivers, Scapy often only sees Ethernet-emulated frames, stripping the 802.11 management headers.
// - The Fix: Implement the code as shown in Step 2. If it doesn't trigger on your laptop, explain to the professor: "This code logic is correct for 802.11 management frames, but the Windows NDIS driver is filtering them before they reach Scapy." He will respect that answer.

// Performance:
// - Parsing every packet in Python is slow. If the UI freezes, increase the sniff(store=0, count=10) count or add a time.sleep in the thread loop to let the CPU breathe.

// Visualization:
// - For the "Protocol Distribution" tab, use a matplotlib Pie Chart fed by self.protocol_stats.
// - For "Network Map," a simple Listbox or Treeview is fine for a midterm; don't over-engineer a graphical topology map unless you have extra time.


Last, 

This code creates a new tab in your notebook, initializes a Matplotlib pie chart, and includes the update loop to make it animate in real-time as packets flow in.

1. Add this to create_overview_tab or a new create_protocol_tab method
- You need to call this method in your __init__ or setup_ui where you build the other tabs.

```

def create_protocol_tab(self):
        """
        Creates the 'Protocol Distribution' tab for Deep Packet Inspection (DPI) visualization.
        Requirement #1: Protocol Distribution Analysis.
        """
        protocol_frame = ctk.CTkFrame(self.notebook)
        self.notebook.add(protocol_frame, text="ðŸ“Š Protocols (DPI)")

        # --- Top Section: Stats & Controls ---
        stats_panel = ctk.CTkFrame(protocol_frame)
        stats_panel.pack(fill="x", padx=10, pady=10)

        ctk.CTkLabel(stats_panel, text="Deep Packet Inspection (DPI)", 
                     font=ctk.CTkFont(size=18, weight="bold")).pack(side="left", padx=10)

        self.packet_count_label = ctk.CTkLabel(stats_panel, text="Total Packets: 0", 
                                             font=ctk.CTkFont(size=14))
        self.packet_count_label.pack(side="right", padx=10)

        # --- Middle Section: The Chart ---
        chart_frame = ctk.CTkFrame(protocol_frame)
        chart_frame.pack(fill="both", expand=True, padx=10, pady=10)

        # Create the Figure and Axes
        self.protocol_fig, self.protocol_ax = plt.subplots(figsize=(6, 5))
        self.protocol_fig.patch.set_facecolor('#2b2b2b') # Match dark theme
        
        # Initial empty chart
        self.protocol_ax.set_facecolor('#2b2b2b')
        self.protocol_ax.text(0.5, 0.5, "Waiting for traffic...", 
                             color='white', ha='center', va='center')
        self.protocol_ax.axis('off')

        # Embed into Tkinter
        self.protocol_canvas = FigureCanvasTkAgg(self.protocol_fig, chart_frame)
        self.protocol_canvas.get_tk_widget().pack(fill="both", expand=True)

        # --- Bottom Section: Detailed Text Stats ---
        details_frame = ctk.CTkScrollableFrame(protocol_frame, height=150)
        details_frame.pack(fill="x", padx=10, pady=10)
        
        self.protocol_details_label = ctk.CTkLabel(details_frame, text="Protocol Details:\nInitializing...", 
                                                 justify="left", font=ctk.CTkFont(family="Consolas", size=12))
        self.protocol_details_label.pack(anchor="w", padx=10, pady=5)

        # Start the update loop for this specific tab
        self.update_protocol_chart()

        ```

2. The Real-Time Update Loop
Add this method to your class. It pulls data from self.protocol_stats (which we defined in the previous step) and redraws the chart.

```

def update_protocol_chart(self):
        """
        Refreshes the Pie Chart with data from the sniffer.
        """
        try:
            # 1. Get snapshot of current data
            if not hasattr(self, 'protocol_stats') or sum(self.protocol_stats.values()) == 0:
                # If no data yet, schedule next check and return
                self.root.after(1000, self.update_protocol_chart)
                return

            labels = []
            sizes = []
            
            # Filter out zero values to keep chart clean
            for proto, count in self.protocol_stats.items():
                if count > 0:
                    labels.append(proto)
                    sizes.append(count)

            # 2. Clear and Redraw
            self.protocol_ax.clear()
            
            # Custom colors for common protocols
            colors = {
                'TCP': '#3498db',   # Blue
                'UDP': '#e67e22',   # Orange
                'ICMP': '#e74c3c',  # Red
                'DNS': '#2ecc71',   # Green
                'HTTPS': '#9b59b6', # Purple
                'HTTP': '#f1c40f',  # Yellow
                'QUIC': '#1abc9c'   # Teal
            }
            
            # Map colors to labels, default to gray if unknown
            chart_colors = [colors.get(l, '#95a5a6') for l in labels]

            # Draw Pie Chart
            wedges, texts, autotexts = self.protocol_ax.pie(
                sizes, 
                labels=labels, 
                autopct='%1.1f%%',
                startangle=90,
                colors=chart_colors,
                textprops=dict(color="white") # White text for dark mode
            )

            # Style the percentage text
            plt.setp(autotexts, size=10, weight="bold")
            plt.setp(texts, size=11)

            self.protocol_ax.set_title("Real-time Protocol Distribution", color='white', pad=20)
            
            # 3. Refresh Canvas
            self.protocol_canvas.draw()

            # 4. Update Text Stats at bottom
            total_packets = sum(sizes)
            self.packet_count_label.configure(text=f"Total Packets: {total_packets}")
            
            stats_text = "Protocol Breakdown:\n" + "-"*30 + "\n"
            sorted_stats = sorted(self.protocol_stats.items(), key=lambda x: x[1], reverse=True)
            for proto, count in sorted_stats:
                pct = (count / total_packets) * 100
                stats_text += f"{proto:<10}: {count:>6} packets ({pct:>5.1f}%)\n"
            
            self.protocol_details_label.configure(text=stats_text)

        except Exception as e:
            print(f"Chart update error: {e}")

        # Schedule next update (every 2 seconds is usually enough to look 'live' without lagging)
        self.root.after(2000, self.update_protocol_chart)

```


3. Integration Checklist
Initialize Data: Ensure self.protocol_stats = defaultdict(int) is in your __init__.

Sniffer Hook: Ensure your _packet_callback is actually incrementing these stats (as shown in Step 2 of the previous response).

Example: self.protocol_stats['TCP'] += 1 inside the callback.

Launch Tab: Add self.create_protocol_tab() to your setup_ui function so the tab actually appears.